В вашем коде все выглядит стандартно, если предположить, что система координат используется классическая прямоугольная декартова система с осями \(x\), \(y\), и \(z\). Вот почему количество направлений обработки различается:

---

### 1. **Движение вперед-назад**
Чтобы камера двигалась вперед или назад, она должна следовать (или двигаться против) направлению своей ориентации (`orient`). Эта ориентация задается вектором, который обычно имеет три компоненты: \(x\), \(y\), и \(z\). Все эти три компоненты определяют направление, в котором «смотрит» камера. 

Например:
- Если ориентация камеры направлена вверх (\(orient = (0, 1, 0)\)), движение вперед будет происходить по \(y\)-координате.
- Если ориентация направлена вдоль оси \(z\) (\(orient = (0, 0, 1)\)), движение вперед произойдет по \(z\)-координате.

Таким образом, для корректного движения вперед или назад необходимо учитывать все три компоненты вектора ориентации камеры.

---

### 2. **Движение влево-вправо**
Для движения камеры влево или вправо используется вектор, перпендикулярный вектору ориентации камеры (в вашем случае `right_vect`). Этот вектор определяет "боковое" направление и строится на основе проекции ориентации камеры на горизонтальную плоскость (\(x-z\)).

- Если камера "смотрит" прямо вперед (\(orient = (0, 0, 1)\)), то движение влево-вправо будет происходить только вдоль \(x\) и \(z\), так как вертикальное смещение (\(y\)) не задействуется.
- Поскольку вектор для левого и правого движения не имеет компоненты \(y\), вам нужно обрабатывать только две оси (\(x\) и \(z\)).

---

### 3. **Движение вверх-вниз**
Для вертикального движения камера просто изменяет свою координату по оси \(y\) без учета ориентации. Это потому, что вверх и вниз — это абсолютные направления, связанные с осью \(y\), и их не нужно выравнивать по ориентации камеры.

---

### Почему так?
Такое поведение полностью стандартно для трёхмерной графики. Это связано с разными ролями осей и ориентации камеры:

1. **Ориентация камеры (вектор `orient`)** определяет направление вперед-назад и влияет на горизонтальные движения (через `right_vect`).
2. **Ось \(y\)** традиционно используется как абсолютное направление для вертикального перемещения в большинстве систем координат (включая DirectX, OpenGL и игры).

### Сравнение с другими системами координат
- В OpenGL или стандартной компьютерной графике \(x\) обычно направлен вправо, \(y\) — вверх, а \(z\) — «из экрана» (или от камеры). Ваш код соответствует этой логике.
- Если ваша система координат была бы, например, "плоской" (2D), движение вперед-назад и влево-вправо обрабатывалось бы только с \(x\) и \(z\), а \(y\) игнорировалось бы.

Таким образом, поведение вашего кода совершенно стандартное для трёхмерной системы координат.